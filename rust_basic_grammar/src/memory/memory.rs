// 在方法内生命的变量, 执行完方法后会被清空内存
// Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 自动 的复制可以被认为对运行时性能影响较小。
fn memory_control () {
    memory_move();
    memory_clone();
}

// 变量与数据交互方式之一: 移动
fn memory_move () {
    // 字符串字面量
    // 因为编译时就确定, 所以不可变
    // 因此内存分配到了栈中
    // 所以处理快速且高效
    let s: &str = "type is &str";
    // 字符串
    // 因为可变, 所以内存分配到了堆上
    // 所以处理起来比栈中的字符串字面量慢而低效
    let mut s: String = String::from("type is");
    s.push_str(" String");

    // s1 声明一个String
    // s1 赋值给s2 (大错特错)? => tips: 上面提到了, String内存分配在堆上
    // 正确: s1会失效, 成为s2, 可以理解为有一个一模一样的s1重命名为s2, 之前的s1失效了
    // 所以可以理解为 s1 移动成为了s2
    // 原因: 上面提到的内存机制
    // 1. 如果两者使用同一份内存, 有一者被清空, 那么另一者就指向空了
    // 2. 如果拷贝一份一模一样的地址, 那么两者释放内存是会释放相同的内存
    // 这是二次释放的错误, 容易造成内存污染和引起内存安全bug之一
    let s1 = String::from("hello");
    let s2 = s1;
}

// 变量与数据交互方式之二: 克隆
fn memory_clone () {
    let s1: String = String::from("clone target");
    // 当使用clone时, 这时才是复制了堆上的数据, 不只是栈上的数据
    // 所以这里是一种深拷贝, 拷贝了所有, 因为这里Rust有自己的处理, 所以并不会释放时引起内存污染和bug
    // 当出现 clone 调用时，一些特定的代码被执行而且这些代码可能相当消耗资源。
    let s2 = s1.clone();
    // 所以下面的代码就可以理解为什么符合我们的第一认知了 => tips: x是已知内容且不可更改的 => tips: 所以此时x的内存存在栈中
    let x: i64 = 5;
    let y = x;
    // 上面这种属于实现了Copy类型, 具体后面会涉及到
    // 其他实现了Copy类型的, 如:
    // 1. 所有整数类型
    // 2. 所有布尔类型
    // 3. 所有浮点数类型
    // 4. 字符类型
    // 5. 元组类型, 仅当其包含的类型也都是Copy的时候
}